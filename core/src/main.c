/**
 * MIT License
 */
#include "main.h"
#include "spi.h"
#include "tim.h"
#include "gpio.h"

#include "lib/ringbuf.h"
#include "lib/serial.h"
#include "lib/serial_cli.h"

#define DEBUG_VIRTUAL_DIGITS 0 /* print digits 13 & 14 */
#define SCAN_START_DELAY 2 /* delay in mks for lines to stabilize */

#define NUM_DIGITS 12 		/* 12 real digit positions */
#define NUM_VIRT   2		/* 2 virtual digit positions */
#define NUM_SCAN_POS (NUM_DIGITS + NUM_VIRT) /* 12 real digit positions and 2 virtual */
#define PROGRAM_RUNNING 0x6F /* '9' at virtual position 0 as a running program flag */

typedef struct scan_s {
	union {
		uint8_t scan_buf[NUM_SCAN_POS]; /** one line of scanned segments codes */
		struct {
			uint8_t digits[NUM_DIGITS]; /** digit scans */
			uint8_t key[NUM_VIRT];      /** key scans */
		};
	};
	uint16_t scan_time; /** number of scan intervals before detecting this line */
} scan_t;

#define NUM_LINES 16
scan_t vfd[NUM_LINES]; /** ring buffer for scanned digits */

#define LINE_TYPE_IDLE   0x00
#define LINE_TYPE_NORMAL 0x40
#define LINE_TYPE_EXEC   0x80

/**
 * ring buffer for event generated by VFD scanner per scanned line
 * high nibble contains LINE_TYPE_*
 * low nibble contains line number for vfd[]
 */
ring_buf_t evbuf;
uint8_t vfd_events[32];

/** high bit of a scan code used by SEG_DOT, and we clear before using this table */
uint8_t seg_map[128] = {
	[0x00] = ' ',
	[0x40] = '-',
	[0x3F] = '0',
	[0x06] = '1',
	[0x5B] = '2',
	[0x4F] = '3',
	[0x66] = '4',
	[0x6D] = '5',
	[0x7D] = '6',
	[0x07] = '7',
	[0x7F] = '8',
	[0x6F] = '9',
	[0x39] = 'C',
	[0x79] = 'E',
	[0x38] = 'L',
	[0x31] = 'R', /* actually, symbol looks like Russian letter 'Г' */
	[0x46] = '{', /* actually, this is '-1' in one position, similar to this: '˧' */
	[0x47] = 'F', /* actually, symbol looks like '-7' in one position or reversed 'F': 'ꟻ' */
	[0x67] = 'P', /* actually, symbol looks like reversed 'P': 'ꟼ' */
};

uint8_t app_flags; /** some flags controlled by CLI */

int main(void)
{
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
	/* Configure the system clock */
	SystemClock_Config();
	/* Initialize all configured peripherals */
	/* initialize DWT for usec resolution delays, will set clocks_per_usec */
	delay_usec_init();
	MX_GPIO_Init();
	MX_SPI2_Init();
	/* use standard HAL init for TIM4, but replace HAL interrupt handler with simple one */
	MX_TIM4_Init();
	/* clear Update Interrupt Flag, to get the first interrupt at needed interval */
	__HAL_TIM_CLEAR_FLAG(&htim4, TIM_SR_UIF);

	rbuf_init(&evbuf, vfd_events, 32);
	/* do not use MX_USART3_UART_Init(); --> replaced with serial_init() */
	serial_init(UART_BR_38400);

	if (clocks_per_usec == 0) /* would never happen */
		serial_puts("DWT init failed!\n");

	cli("help", NULL);
	cli_init();

	bool blank = false; /* true if previous line was blank */
	/* then main  loop */
	while (true) {
		cli_interact(cli, NULL);
		/**
		 * display scanner will send an event
		 * bits 7..6 - scan line type: normal or detected program execution
		 * bits 5..0 - scan buffer line index to read
		 * if all bits are 0 then all digits are off
		 */
		if (rbuf_size(&evbuf)) {
			uint8_t i, line;
			uint8_t line_type = rbuf_read(&evbuf);
			if (line_type != LINE_TYPE_IDLE) {
				line = line_type & ~(LINE_TYPE_NORMAL | LINE_TYPE_EXEC);
				if (blank) {
					uint32_t cycle_time = (htim4.Instance->ARR + 1) * NUM_SCAN_POS;
					serial_print(" %u cycles (%u,%u ms)\n", vfd[line].scan_time,
								 (vfd[line].scan_time * cycle_time) / 1000,
								 (vfd[line].scan_time * cycle_time) % 1000);
				}
				if (app_flags & APP_PRINT_HEX_SCAN) {
					for (i = 0; i < NUM_SCAN_POS; i++)
						serial_print("%02X ", vfd[line].scan_buf[i]);
				}
				serial_putc('\'');
				for (i = 0; i < NUM_SCAN_POS; i++) {
					uint8_t scan = vfd[line].scan_buf[i];
					uint8_t sym = seg_map[scan & 0x7F];
					if (sym) {
						serial_putc(sym);
						if (scan & SEG_DOT)
							serial_putc('.');
						if (i == (NUM_DIGITS - 1))
							serial_puts("' ["); /* print virtual digits in brackets */
					} else
						serial_print("(%02X)", scan);
				}
				serial_print("]");
				if (line_type & LINE_TYPE_EXEC)
					serial_puts(" RUNNIG");
				serial_putc('\n');
				blank = false;
			} else {
				serial_puts("'             '");
				blank = true;
			}
		}
	}
}

/**
 * Display scanner is implemented two interrupts:
 * 1. Interrupt on the rising edge of the pin wired to digit 8 grid control signal
 * 2. Timer 4 interupt
 *
 * First interrupt reads segments of the digit 8 and then start TIM4 counter.
 * TIM4 interrupts 13 times and scans corresponding digit segments.
 * The last interrupt of this cycle will check if any changes detected and
 * will send notification event to the main loop
 */
uint32_t scan_ts; 				/* scan start timestamp */
volatile uint32_t scan_period; 	/* interval between scan pin interrupts, in usec */
volatile uint32_t tim_arr; 		/* timer auto reload register */
static scan_t   raw;	   		/* buffer to store single scan data */
static uint8_t  digit_idx; 		/* index of a digit being scanned, 0 - scan pin interrupt */
static uint8_t  scan_line; 		/* index of the scan buffer entry */
static uint16_t raw_new;   		/* mask of values changed from the last scan */
static uint16_t raw_valid; 		/* mask of digits with at least one segment on */

/* mapping to convert our scanning indexes to digits' indexes */
static const uint8_t digits_map[NUM_SCAN_POS] = {8, 7, 6, 5, 4, 3, 2, 1, 0, 11, 10, 9, 12, 13};

static inline void read_segments(uint8_t idx) {
	uint16_t reg = SEG_GPIO_Port->IDR;
	uint16_t seg = reg & SEG_PINS;
	if (seg)
		raw_valid |= 1 << idx;
	if (raw.scan_buf[idx] != seg)
		raw_new |= 1 << idx;
	raw.scan_buf[idx] = seg;
}

/**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	led_on(); /* pulse for oscilloscope for execution teracking */
	/* the first call of the interrupt, store the current system clock counter */
	if (scan_ts == 0) {
		scan_ts = DWT->CYCCNT;
		goto exit;
	}

	scan_period = DWT->CYCCNT - scan_ts;
	scan_ts = DWT->CYCCNT;
	scan_period /= clocks_per_usec;
	if (scan_period < 1000) /* ignore any very short intervals: MK52 is starting up */
		goto exit;
	/* re-calculate and update scanning timer period */
	tim_arr = scan_period / NUM_SCAN_POS;
	tim_set_arr(TIM4, tim_arr + 2); /* 2 usec extra delay for the first tim interrupt */

	delay_usec(SCAN_START_DELAY); /* small delay for segments' signals to stabilize */
	/* reset counter for a new scan cycle */
	digit_idx = 0;
	raw_new = raw_valid = 0;
	read_segments(digits_map[digit_idx++]);
	tim_enable(TIM4); /* start our scanning timer */
exit:
	led_off();
	/* ~5.4 us if SCAN_START_DELAY is 2us */
}

/**
 * use our own timer IRQ handler as we do not need all extra HAL stuff
 * for our simple timer configuration
 */
void TIM4_IRQHandler(void)
{
	dbg_low();
	read_segments(digits_map[digit_idx++]);

	if (digit_idx == NUM_SCAN_POS) { /* last scan interrupt */
		tim_disable(TIM4);

		if (!(app_flags & APP_PRINT_KEY_SCAN)) {
			/* ignore virtual digits to avoid false positive events */
			raw_new &= 0x0FFF;
			raw_valid &= 0x0FFF;
		}

		/* at list one real digit had changed */
		if (raw_new && raw_valid) {
			raw.scan_buf[0] &= SEG_G; /* only '-' is valid for the first position */
			memcpy(&vfd[scan_line], &raw, sizeof(scan_t));
			if (raw.key[0] == PROGRAM_RUNNING)
				scan_line |= LINE_TYPE_EXEC;
			else
				scan_line |= LINE_TYPE_NORMAL;
			rbuf_write(&evbuf, scan_line);
			scan_line = (scan_line + 1) & (NUM_LINES - 1);
			raw.scan_time = 0;
		} else if (!raw_valid) { /* all digits are blank */
			if (!raw.scan_time)	 /* first invalid scan */
				rbuf_write(&evbuf, 0);
			raw.scan_time += 1;
		}
	}
	/**
	 * a small compensation for IRQ handler code execution
	 * '0x03' value had been handpicked using an oscilloscope
	 * */
	if ((digit_idx & 0x03) == 0x03)
		tim_arr -= 2;
	tim_set_arr(TIM4, tim_arr);

	/** tim_set_arr() resets interrupt flag for us,
	 * no need to reset it here
	TIM4->SR &= ~TIM_SR_UIF;
	*/
	dbg_high();
	/* ~1.0us for normal scan */
	/* ~2.5us for the last scan */
}
